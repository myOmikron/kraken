{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contribution/css/","title":"CSS","text":""},{"location":"contribution/css/#performance-considerations","title":"Performance considerations","text":"<p>Since GPU rendering of a large count of DOM counts can significantly slow down devices, do NOT apply CSS directives that move the element composition onto the GPU on a large amount of DOM nodes unless absolutely necessary.</p> <p>Historically panes have all have had a 1px background blur, which caused massive lags and graphical glitches, since panes are used everywhere.</p>"},{"location":"contribution/css/#filter-backdrop-filter","title":"<code>filter</code>, <code>backdrop-filter</code>","text":"<p>filter: blur</p> <pre><code>    backdrop-filter: blur(...);\n    filter: blur(...);\n</code></pre> <p>Blurs can help differentiate foreground content from background content. Only use them in combination with user-dismissible popups.</p> <p>Never use blurs on content that is permanently visible without user interaction or can't be removed from the render DOM.</p> <p>More opaque background colors as well as gradients and box shadows should be used instead.</p> <p>filter: drop-shadow</p> <pre><code>    filter: drop-shadow(...);\n</code></pre> <p>Drop shadow is a more accurate shadow than a box shadow and can accurately trace the outline of the element / image. Only use this when the shape is not a (rounded) rectangle, since it's not as well optimized as a <code>box-shadow</code> and doesn't offer as much control.</p>"},{"location":"contribution/css/#keyframes-property","title":"<code>@keyframes</code>, <code>@property</code>","text":"<p>Animating CSS --variables</p> <pre><code>@keyframes {\n    ... { --my-variable: ...; }\n}\n</code></pre> <p>Animating CSS variables is only supported on chromium based browsers and when a <code>@property</code> for them is defined. On Firefox the animation will be skipped / just switch from one value to the other in the half-way point of the animation.</p> <p>Avoid if possible, only use for things where a missing animation wouldn't cause it to look too bad.</p>"},{"location":"contribution/css/#transition-animation-will-change","title":"<code>transition</code>, <code>animation</code>, <code>will-change</code>","text":"<p>Animating filters</p> <pre><code>    transition: filter ...;\n    transition: all ...;\n    will-change: filter;\n</code></pre> <p>Having filters potentially animated can cause the browser to possibly render the element on the GPU. Avoid applying this to many elements at once since the behavior can be unpredictable.</p> <p>This will usually not cause issues, but should be considered as a last resort depending on the target result. Filter animations can very easily become laggy and certain stuff like color manipulation can often be solved by adjusting colors.</p>"},{"location":"contribution/css/#transform-scale-rotate-animation","title":"<code>transform</code>, <code>scale</code>, <code>rotate</code> (+ <code>animation</code>)","text":"<p>Transforms</p> <pre><code>    transform: scale(...) rotate(...);\n    scale: ...;\n    rotate: ...;\n    animation: my-transform-animation ...;\n</code></pre> <p>Scaling and rotation can also move element rendering onto the GPU as well as make text potentially blurry, especially when animated.</p> <p>Consider the impacts and try to use them on short interaction animations or for fixed transforms. Avoid too many active transform animations at once on a page.</p>"},{"location":"contribution/css/#practical-examples","title":"Practical examples","text":"<p>From previous historical issues:</p> <p>Do</p> <pre><code>.my-popup { /* filter / 3D transform / etc. */ }\n</code></pre> <p>Popups are only visible for a short amount of time, usually via user-interaction, and usually only exist once or twice at once. Blurs and such can help distinguish content and give improved looks.</p> <p>Don't</p> <pre><code>.pane { /* filter / 3D transform / etc. */ }\n</code></pre> <p>A pane is always visible and there are potentially a lot of them. Blurs are unnecessary since there is usually no content behind them other than the background anyway. To help keep text readable with the animated matrix background behind it, instead consider increasing the background opacity to make it more opaque and adjusting the colors accordingly.</p> <p>The built-in pane classes already help do all of this.</p> <p>Don't</p> <pre><code>    backdrop-filter: blur(0.1em);\n</code></pre> <p>This blur is likely equal to 1-2px of blur. An amount that is unlikely to give any readability improvements, nor look very good. Consider a higher background opacity instead and remove the blur entirely.</p> <p>Don't</p> <pre><code>button { backdrop-filter: blur(40px); }\n</code></pre> <p>A button is usually a small element and this applies a massive blur, which is likely going to just result in a single color. Instead use a color picker to pick the color and just use it as opaque background, possibly with a little opacity for a nicer look. Gradients may also help achieve this effect on larger elements.</p>"},{"location":"contribution/dev_setup/","title":"Development Environment","text":""},{"location":"contribution/dev_setup/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The easiest way to get kraken running locally is using Vagrant and the provided Vagrantfile, which starts and uses virtual machines that take care of most things automatically, including compilation, through Ansible.</p>"},{"location":"contribution/dev_setup/#vagrantvarsyml","title":"<code>vagrant/vars.yml</code>","text":"<p>Copy the <code>example.vars.yml</code> to <code>vars.yml</code> in the vagrant folder and set test values for the tokens, names and passwords. A sample <code>vars.yml</code> might start like this:</p> <pre><code>---\n- kraken_db_name: \"kraken\"\n  kraken_db_user: \"kraken\"\n  kraken_db_password: \"\"\n  kraken_secret_key: \"\"\n  origin_uri: \"https://kraken.localhost\"\n  server_name: \"kraken.localhost\"\n  leech_db_name: \"leech\"\n  leech_db_user: \"leech\"\n  leech_db_password: \"\"\n  ...\n</code></pre> <p>The server will only listen to requests on the <code>origin_uri</code> URL. For this example, you can add <code>127.0.0.1   kraken.localhost</code> to your <code>/etc/hosts</code> file.</p> <p>The <code>kraken_secret_key</code> and <code>generated_leech_conf</code> blocks can first be left as-is and need to be filled with generated information after the first startup.</p>"},{"location":"contribution/dev_setup/#creating-vms","title":"Creating VMs","text":"<p>Before the first startup, if you don't have a high-spec machine with 8 or more cores, make sure to reduce the VM CPUs inside the root Vagrantfile in the checked out kraken repository. Using more VM CPUs than what are available on the host may cause hangups and slowdowns. If you change these values later, you can restart the VM with the config using <code>vagrant reload</code></p> <p>Now, initialize the VMs and perform a first compilation using</p> <pre><code>$ vagrant up\n</code></pre> <p>If you access http://kraken.localhost:8081 now, you should see a broken black page saying \"Loading...\" as well as showing errors.</p>"},{"location":"contribution/dev_setup/#setup-admin-user-and-kraken-key","title":"Setup admin user and kraken key","text":"<p>Now open a shell in the VM using</p> <pre><code>$ vagrant ssh\n</code></pre> <p>and inside this shell create an admin user by running <pre><code>$ sudo kraken create-admin-user\nEnter a username:\nEnter a display name:\nEnter password:\n[2023-12-13 11:12:17 | DEBUG | rorm_db::database] SQL: SELECT \"user\".\"uuid\" AS user__uuid FROM \"user\" WHERE (\"user\".username = $1) LIMIT 1;\n[2023-12-13 11:12:17 | DEBUG | rorm_db::database] SQL: INSERT INTO \"user\" (\"uuid\", \"username\", \"display_name\", \"permission\") VALUES ($1, $2, $3, 'Admin');\n[2023-12-13 11:12:17 | DEBUG | rorm_db::database] SQL: INSERT INTO \"localuser\" (\"uuid\", \"user\", \"password_hash\") VALUES ($1, $2, $3);\n\nCreated user admin\n</code></pre></p> <p>Following this run keygen:</p> <pre><code>$ sudo kraken keygen\nuRi7GQJkXSSM9oeYvOunX5X0izMSLOq5CItHC...\n</code></pre> <p>Copy the key that is output from this command and put it into <code>kraken_secret_key</code> inside your <code>vars.yml</code> file.</p> <p>Now exit the shell with Ctrl+D and since we edited <code>vars.yml</code> you need to re-provision the VM:</p> <pre><code>$ vagrant provision kraken\n</code></pre> <p>Now reload the Kraken webpage (http://kraken.localhost:8081) and login using the credentials that you have entered previously.</p>"},{"location":"contribution/dev_setup/#first-time-configuration","title":"First-time configuration","text":"<p>Once logged in as admin, go to the \"Kraken Network\" page and click \"Add leech\"</p> <p>Pick any name, for example \"Default leech\" and as address use</p> <pre><code>https://10.13.37.11:31337\n</code></pre> <p>When added to the list, click on \"Gen tls config\"</p> <p>The TLS config will be copied to clipboard (KrakenSni, KrakenCa, etc.). Paste this configuration inside your <code>vars.yml</code> as value for the <code>generated_leech_conf</code> field. Note that the formatting must be all in the same column like this:</p> <pre><code>...\n  generated_leech_conf: |\n    KrakenSni = \"...\"\n    KrakenCa = \"\"\"\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n    \"\"\"\n    LeechCert = \"\"\"\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n    \"\"\"\n    LeechKey=\"\"\"\n    -----BEGIN PRIVATE KEY-----\n    ...\n    -----END PRIVATE KEY-----\n    \"\"\"\n    LeechSecret = \"...\"\n</code></pre> <p>Now since <code>vars.yml</code> has been modified, you need to re-provision the leech VM again:</p> <pre><code>$ vagrant provision leech\n</code></pre> <p>The leech should be available now and attacks in workspaces can now be done.</p>"},{"location":"contribution/dev_setup/#internal-files","title":"Internal files","text":"<p>The following paths are used for storage and configuration: <pre><code>kraken:\n    /etc/kraken/config.toml\n    /var/lib/kraken\n\nleech:\n    /etc/leech/config.toml\n</code></pre></p>"},{"location":"contribution/new_attack/","title":"How to implement a new attack","text":""},{"location":"contribution/new_attack/#leechs-code","title":"Leech's code","text":""},{"location":"contribution/new_attack/#1-the-actual-logic","title":"1. The actual logic","text":"<ul> <li>Create a new rust module under <code>leech/src/modules</code></li> <li>It should expose a single async function to run your attack</li> <li>Figure out if your attack should be streamed or not</li> </ul> <p>Example</p> <pre><code>pub struct PortGuesserSettings {\n    pub addresses: Vec&lt;IpNetwork&gt;,\n    pub num_ports: u32,\n}\npub struct PortGuesserResult {\n    pub host: IpAddr,\n    pub port: u16,\n}\npub type PortGuesserError = SendError&lt;PortGuesserResult&gt;;\n\npub async fn port_guesser(\n    settings: PortGuesserSettings,\n    tx: Sender&lt;PortGuesserResult&gt;, // &lt;- this attack is streamed so we \"return\" our results through a channel\n) -&gt; Result&lt;(), PortGuesserError&gt; {\n    let mut rng = StdRng::from_entropy();\n    for network in settings.addresses {\n        for addr in network.iter() {\n            for _ in 0..settings.num_ports {\n                tx.send(PortGuesserResult {\n                    host: addr,\n                    port: rng.gen_range(1..=u16::MAX),\n                })\n                .await?;\n            }\n        }\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"contribution/new_attack/#2-expose-it-on-the-cli","title":"2. Expose it on the cli","text":"<ul> <li>Create a new <code>RunCommand</code> variant in <code>leech/src/main.rs</code></li> <li> <p>Add the associated match arm to execute your function in <code>fn main()</code></p> <p>(the compiler will tell you where)</p> </li> </ul> <p>Example</p> <pre><code>#[derive(Subcommand)]\npub enum RunCommand {\n    // ...\n\n    PortGuesser {\n        #[clap(required(true))]\n        targets: Vec&lt;String&gt;,\n\n        #[clap(short, long, default_value_t = 4)]\n        num_ports: u32,\n    },\n}\n\n// inside main\nmatch command {\n    // ...\n\n    RunCommand::PortGuesser { targets, num_ports } =&gt; {\n        let addresses = targets\n            .iter()\n            .map(|s| IpNetwork::from_str(s))\n            .collect::&lt;Result&lt;_, _&gt;&gt;()?;\n        let (tx, mut rx) = mpsc::channel(1);\n        task::spawn(port_guesser(\n            PortGuesserSettings {\n                addresses,\n                num_ports,\n            },\n            tx,\n        ));\n        while let Some(res) = rx.recv().await {\n            info!(\"I guess {}:{} is open\", res.host, res.port);\n        }\n    }\n}\n</code></pre>"},{"location":"contribution/new_attack/#3-expose-it-over-grpc","title":"3. Expose it over grpc","text":"<ul> <li>Create two new message types in <code>proto/attacks.proto</code>, a <code>...Request</code> and a <code>...Response</code></li> <li>The request should contain your function's arguments and the response should contain its results</li> <li>Extend <code>ReqAttackService</code> with a new call using your request and response messages</li> <li> <p>Extend the <code>PushAttackRequest.response</code> with your new response</p> <p>(make it repeated if your attack is streamed)</p> </li> <li> <p>Extend the <code>AnyAttackResponse.response</code> with your new response</p> <p>(never make it repeated)</p> </li> <li> <p>Implement the new method on <code>ReqAttackService</code>, the compiler will now complain about</p> <p>It should convert the <code>...Request</code> object to your functions arguments and its result to <code>...Response</code>.</p> <p>When your attack is streamed, you might find the function <code>stream_attack</code> helpful to construct the return value.</p> </li> </ul> <p>Example</p> <pre><code>message PortGuesserRequest {\n  string attack_uuid = 1;\n  repeated attacks.shared.NetOrAddress targets = 2;\n  uint32 num_ports = 3;\n}\n\nmessage PortGuesserResponse {\n  attacks.shared.Address host = 1;\n  uint32 port = 2;\n}\n\nservice ReqAttackService {\n  // ...\n\n  rpc PortGuesser(PortGuesserRequest) returns (stream PortGuesserResponse);\n}\n</code></pre> <pre><code>message PushAttackRequest {\n  // ...\n\n  oneof response {\n    // ...\n\n    RepeatedPortGuesserResponse port_guesser = 9;\n    // ^\n    // | if the attack is not streamed, just use `PortGuesserResponse` here\n  }\n}\n\nmessage RepeatedPortGuesserResponse {\n  repeated PortGuesserResponse responses = 1;\n}\n</code></pre> <pre><code>message AnyAttackResponse {\n  // ...\n\n  oneof response {\n    // ...\n\n    PortGuesserResponse port_guesser = 8;\n  }\n}\n</code></pre> <pre><code>impl ReqAttackService for Attacks {\n    // ...\n\n    type PortGuesserStream =\n        Pin&lt;Box&lt;dyn Stream&lt;Item = Result&lt;PortGuesserResponse, Status&gt;&gt; + Send&gt;&gt;;\n\n    async fn port_guesser(\n        &amp;self,\n        request: Request&lt;PortGuesserRequest&gt;,\n    ) -&gt; Result&lt;Response&lt;Self::PortGuesserStream&gt;, Status&gt; {\n        let req = request.into_inner();\n\n        let attack_uuid = Uuid::parse_str(&amp;req.attack_uuid)\n            .map_err(|_| Status::invalid_argument(\"attack_uuid has to be an Uuid\"))?;\n\n        let settings = PortGuesserSettings {\n            addresses: req.targets.into_iter().map(|el| el.into()).collect(),\n            num_ports: req.num_ports,\n        };\n\n        self.stream_attack(\n            attack_uuid,\n            |tx| async move {\n                port_guesser(settings, tx)\n                    .await\n                    .map_err(|_| Status::unknown(\"\"))\n            },\n            |value| PortGuesserResponse {\n                host: Some(value.host.into()),\n                port: value.port as u32,\n            },\n            any_attack_response::Response::PortGuesser,\n        )\n    }\n}\n</code></pre> <p>Info</p> <p>kraken won't compile anymore</p>"},{"location":"contribution/new_attack/#krakens-code","title":"Kraken's code","text":""},{"location":"contribution/new_attack/#4-db-models","title":"4. DB models","text":"<ul> <li>Add your new attack type to <code>AttackType</code> in <code>kraken/src/models/attack/mod.rs</code>   and <code>SourceType</code> in <code>kraken/src/models/aggregation/mod.rs</code></li> <li> <p>Add models in <code>kraken/src/models/attack/mod.rs</code> to store your attack's raw results</p> <p>(A raw result is the <code>...Response</code> message you defined in step 3)</p> <p>Don't forget to create an insertable patch as well!</p> </li> </ul> <p>Warning</p> <p>Please consult your project lead on how to migrate the <code>AttackType</code> and <code>SourceType</code> enums</p> <p>Example</p> <p><pre><code>#[derive(DbEnum)]\npub enum SourceType {\n    // ...\n\n    PortGuesser,\n}\n\n#[derive(DbEnum)]\npub enum AttackType {\n    // ...\n\n    PortGuesser,\n}\n</code></pre> <pre><code>#[derive(Model)]\npub struct PortGuesserResult {\n    #[rorm(primary_key)]\n    pub uuid: Uuid,\n\n    #[rorm(on_delete = \"Cascade\", on_update = \"Cascade\")]\n    pub attack: ForeignModel&lt;Attack&gt;,\n\n    #[rorm(auto_create_time)]\n    pub created_at: DateTime&lt;Utc&gt;,\n\n    pub host: IpNetwork,\n\n    pub port: i32,\n}\n\n#[derive(Patch)]\n#[rorm(model = \"PortGuesserResult\")]\npub(crate) struct PortGuesserResultInsert {\n    pub(crate) uuid: Uuid,\n    pub(crate) attack: ForeignModel&lt;Attack&gt;,\n    pub(crate) host: IpNetwork,\n    pub(crate) port: i32,\n}\n</code></pre></p>"},{"location":"contribution/new_attack/#5-handle-your-grpc-messages","title":"5. Handle your grpc messages","text":"<ul> <li> <p>Implement <code>HandleAttackResponse&lt;...Response&gt;</code> for <code>AttackContext</code></p> <p>This is done in an attack specific submodule in <code>kraken/src/modules/attacks</code>.</p> <p>The <code>handle_response</code> method, you will have to implement, should:</p> <ul> <li>Validate and convert your <code>...Response</code> message</li> <li> <p>Notify the user via <code>self.send_ws</code></p> <p>(you might need to create a new websocket message type)</p> </li> <li> <p>Store the raw result</p> </li> <li>Update the aggregations via <code>GLOBAL.aggregator</code></li> <li>Connect the raw result with the aggregated models using the <code>AggregationSource</code> m2m relation</li> </ul> </li> <li> <p>Extend the 3 match statements in <code>kraken/src/rpc/server.rs</code> using your <code>AttackType</code> variant and <code>handle_response</code> impl.</p> </li> </ul> <p>Example</p> <p><pre><code>impl HandleAttackResponse&lt;PortGuesserResponse&gt; for AttackContext {\n    async fn handle_response(&amp;self, response: PortGuesserResponse) -&gt; Result&lt;(), AttackError&gt; {\n        let PortGuesserResponse {\n            host: Some(host),\n            port,\n        } = response\n        else {\n            return Err(AttackError::Malformed(\"Missing `host`\"));\n        };\n        let host = IpNetwork::from(IpAddr::try_from(host)?);\n\n        let source_uuid = insert!(&amp;GLOBAL.db, PortGuesserResultInsert)\n            .return_primary_key()\n            .single(&amp;PortGuesserResultInsert {\n                uuid: Uuid::new_v4(),\n                attack: ForeignModelByField::Key(self.attack_uuid),\n                host,\n                port: port as i32,\n            })\n            .await?;\n\n        let host_uuid = GLOBAL\n            .aggregator\n            .aggregate_host(self.workspace.uuid, host, HostCertainty::SupposedTo)\n            .await?;\n        let port_uuid = GLOBAL\n            .aggregator\n            .aggregate_port(\n                self.workspace.uuid,\n                host_uuid,\n                port as u16,\n                PortProtocol::Tcp,\n                PortCertainty::SupposedTo,\n            )\n            .await?;\n\n        insert!(&amp;GLOBAL.db, AggregationSource)\n            .return_nothing()\n            .bulk([\n                AggregationSource {\n                    uuid: Uuid::new_v4(),\n                    workspace: ForeignModelByField::Key(self.workspace.uuid),\n                    source_type: SourceType::PortGuesser,\n                    source_uuid,\n                    aggregated_table: AggregationTable::Host,\n                    aggregated_uuid: host_uuid,\n                },\n                AggregationSource {\n                    uuid: Uuid::new_v4(),\n                    workspace: ForeignModelByField::Key(self.workspace.uuid),\n                    source_type: SourceType::PortGuesser,\n                    source_uuid,\n                    aggregated_table: AggregationTable::Port,\n                    aggregated_uuid: port_uuid,\n                },\n            ])\n            .await?;\n\n        Ok(())\n    }\n}\n</code></pre> <pre><code>// three match expressions in kraken/src/rpc/server.rs\n\nmatch &amp;response {\n    // ...\n    push_attack_request::Response::PortGuesser(_) =&gt; AttackType::PortGuesser,\n},\n\nlet result = match response {\n    // ...\n    push_attack_request::Response::PortGuesser(repeated) =&gt; {\n        attack.handle_vec_response(repeated.responses).await\n    }\n};\n\nlet result: Result&lt;(), _&gt; = match response {\n    // ...\n    any_attack_response::Response::PortGuesser(response) =&gt; {\n        attack_context.handle_response(response).await\n    }\n};\n</code></pre></p>"},{"location":"contribution/new_attack/#6-write-schemas-and-handler-to-retrieve-raw-results","title":"6. Write schemas and handler to retrieve raw results","text":"<p>Add utoipa pagination structs to <code>kraken/src/api/handler/common/schema.rs</code>.</p> <p>Write an http handler in <code>kraken/src/api/handler/attack_results/handler.rs</code> to query your raw attack results (the model you created in step 4).</p> <p>We are doing this step now, because you'll have to write new schemas for the handler's response, which we'll also need in the next step.</p> <p>Example</p> <pre><code>// kraken/src/api/handler/common/schema.rs\npub use utoipa_fix::{\n    ..., PortGuesserResultsPage, ...\n}\n\n...\n\n#[allow(missing_docs)]\nmod utoipa_fix {\n    use crate::api::handler::attack_results::schema::{\n        ..., PortGuesserResult, ...\n    }\n\n    #[derive(Serialize, Deserialize, Default, ToSchema, Clone)]\n    #[aliases(\n        ...\n        PortGuesserResultsPage = Page&lt;PortGuesserResult&gt;,\n    )]\n    pub struct Page&lt;T&gt; {\n        ...\n    }\n    ...\n}\n...\n</code></pre> <p><pre><code>// kraken/src/api/handler/attack_results/handler.rs\n\n#[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\npub struct SimplePortGuesserResult {\n    pub uuid: Uuid,\n    pub attack: Uuid,\n    pub created_at: DateTime&lt;Utc&gt;,\n    #[schema(value_type = String, example = \"127.0.0.1\")]\n    pub address: IpNetwork,\n    pub port: u16,\n}\n</code></pre> <pre><code>#[utoipa::path(\n    tag = \"Attacks\",\n    context_path = \"/api/v1\",\n    responses(\n        (status = 200, description = \"Returns attack's results\", body = PortGuesserResultsPage),\n        (status = 400, description = \"Client error\", body = ApiErrorResponse),\n        (status = 500, description = \"Server error\", body = ApiErrorResponse),\n    ),\n    params(PathUuid, PageParams),\n    security((\"api_key\" = []))\n)]\n#[get(\"/attacks/{uuid}/portGuesserResults\")]\npub async fn get_port_guesser_results(\n    path: Path&lt;PathUuid&gt;,\n    page_params: Query&lt;PageParams&gt;,\n    SessionUser(user_uuid): SessionUser,\n) -&gt; ApiResult&lt;Json&lt;PortGuesserResultsPage&gt;&gt; {\n    let mut tx = GLOBAL.db.start_transaction().await?;\n\n    let attack_uuid = path.uuid;\n    let (limit, offset) = get_page_params(page_params.0).await?;\n\n    if !Attack::has_access(&amp;mut tx, attack_uuid, user_uuid).await? {\n        return Err(ApiError::MissingPrivileges);\n    }\n\n    let (total,) = query!(&amp;mut tx, (PortGuesserResult::F.uuid.count(),))\n        .condition(PortGuesserResult::F.attack.equals(attack_uuid))\n        .one()\n        .await?;\n\n    let items = query!(&amp;mut tx, PortGuesserResult)\n        .condition(PortGuesserResult::F.attack.equals(attack_uuid))\n        .limit(limit)\n        .offset(offset)\n        .stream()\n        .map_ok(|x| SimplePortGuesserResult {\n            uuid: x.uuid,\n            attack: *x.attack.key(),\n            created_at: x.created_at,\n            address: x.host,\n            port: x.port as u16,\n        })\n        .try_collect()\n        .await?;\n\n    tx.commit().await?;\n\n    Ok(Json(Page {\n        items,\n        limit,\n        offset,\n        total: total as u64,\n    }))\n}\n</code></pre></p>"},{"location":"contribution/new_attack/#7-handle-the-new-sourcetype","title":"7. Handle the new <code>SourceType</code>","text":"<ul> <li>Add a new <code>usize</code> field to <code>SimpleAggregationSource</code> in <code>kraken/src/api/handler/aggregation_source/schema.rs</code></li> <li>Increment this field in <code>SimpleAggregationSource::add</code> in <code>kraken/src/api/handler/aggregation_source/utils.rs</code></li> <li>Add a new variant to <code>SourceAttackResult</code> in <code>kraken/src/api/handler/aggregation_source/schema.rs</code></li> <li>Add the logic required to query your attack type's raw results for a specific aggregated model   (<code>FullAggregationSource::query</code> in <code>kraken/src/api/handler/aggregation_source/utils.rs</code>)</li> </ul> <p>Example</p> <p><pre><code>pub struct SimpleAggregationSource {\n    // ...\n\n    pub port_guesser: usize,\n}\n</code></pre> <pre><code>match source_type {\n    // ...\n\n    SourceType::PortGuesser =&gt; self.port_guesser += 1,\n}\n</code></pre> <pre><code>pub enum SourceAttackResult {\n  // ...\n\n  PortGuesser(Vec&lt;SimplePortGuesserResult&gt;),\n}\n</code></pre> <pre><code>type Results&lt;T&gt; = HashMap&lt;Uuid, Vec&lt;T&gt;&gt;;\n// ...\nlet mut port_guesser: Results&lt;SimplePortGuesserResult&gt; = Results::new();\n\n// ...\n\nmatch source_type {\n    // ...\n\n    SourceType::PortGuesser =&gt; {\n        let mut stream = query!(&amp;mut *tx, PortGuesserResult)\n            .condition(field_in(PortGuesserResult::F.uuid, uuids))\n            .stream();\n        while let Some(result) = stream.try_next().await? {\n            port_guesser.entry(*result.attack.key()).or_default().push(\n                SimplePortGuesserResult {\n                    uuid: result.uuid,\n                    attack: *result.attack.key(),\n                    created_at: result.created_at,\n                    address: result.host,\n                    port: result.port as u16,\n                },\n            );\n        }\n    }\n}\n\n// ...\n\nmatch attack_type {\n    // ...\n\n    AttackType::PortGuesser =&gt; SourceAttackResult::PortGuesser(\n        port_guesser.remove(&amp;uuid).unwrap_or_default(),\n    ),\n}\n</code></pre></p> <p>Info</p> <p>kraken should compile again</p> <p>frontend's data view will break</p>"},{"location":"contribution/new_attack/#8-expose-it-over-the-api","title":"8. Expose it over the API","text":"<ul> <li> <p>Add a method to <code>AttackContext</code> in your submodule of <code>kraken/src/modules/attacks</code> which runs the attack</p> <p>This method should be a thin wrapper which converts the attack's params to grpc and handle the response.</p> <p>(Use <code>handle_response</code> you implemented in step 5 or <code>handle_streamed_response</code> if you're attack is streamed)</p> </li> <li> <p>Add a function in <code>kraken/src/modules/attacks/mod.rs</code> which calls this method in a new task</p> </li> <li> <p>Add an endpoint in <code>kraken/src/api/handler/attacks/handler.rs</code> which calls this function</p> </li> </ul> <p>Example</p> <pre><code>impl AttackContext {\n    pub async fn port_guesser(\n        &amp;self,\n        mut leech: LeechClient,\n        params: PortGuesserParams,\n    ) -&gt; Result&lt;(), AttackError&gt; {\n        let targets =\n            DomainOrNetwork::resolve(self.workspace.uuid, self.user.uuid, &amp;leech, &amp;params.targets)\n                .await?;\n\n        self.handle_streamed_response(leech.port_guesser(PortGuesserRequest {\n            attack_uuid: self.attack_uuid.to_string(),\n            targets: targets.into_iter().map(From::from).collect(),\n            num_ports: params.num_ports,\n        }))\n        .await\n    }\n}\n</code></pre> <pre><code>pub struct PortGuesserParams {\n    pub targets: Vec&lt;DomainOrNetwork&gt;,\n    pub num_ports: u32,\n}\npub async fn start_port_guesser(\n    workspace: Uuid,\n    user: Uuid,\n    leech: LeechClient,\n    params: PortGuesserParams,\n) -&gt; Result&lt;(Uuid, JoinHandle&lt;()&gt;), InsertAttackError&gt; {\n    let ctx = AttackContext::new(workspace, user, AttackType::PortGuesser).await?;\n    Ok((\n        ctx.attack_uuid,\n        tokio::spawn(async move {\n            ctx.set_started().await;\n            let result = ctx.port_guesser(leech, params).await;\n            ctx.set_finished(result).await;\n        }),\n    ))\n}\n</code></pre> <pre><code>#[derive(Deserialize, Serialize, Debug, ToSchema)]\npub struct PortGuesserRequest {\n  pub leech_uuid: Option&lt;Uuid&gt;,\n  #[schema(value_type = Vec&lt;String&gt;)]\n  pub targets: Vec&lt;DomainOrNetwork&gt;,\n  pub num_ports: u32,\n  pub workspace_uuid: Uuid,\n}\n</code></pre> <pre><code>#[utoipa::path(\n    tag = \"Attacks\",\n    context_path = \"/api/v1\",\n    responses(\n        (status = 202, description = \"Attack scheduled\", body = UuidResponse),\n        (status = 400, description = \"Client error\", body = ApiErrorResponse),\n        (status = 500, description = \"Server error\", body = ApiErrorResponse)\n    ),\n    request_body = PortGuesserRequest,\n    security((\"api_key\" = []))\n)]\n#[post(\"/attacks/portGuesser\")]\npub async fn port_guesser(\n    req: Json&lt;PortGuesserRequest&gt;,\n    SessionUser(user_uuid): SessionUser,\n) -&gt; ApiResult&lt;HttpResponse&gt; {\n    let PortGuesserRequest {\n        leech_uuid,\n        targets,\n        num_ports,\n        workspace_uuid,\n    } = req.into_inner();\n\n    if targets.is_empty() {\n        return Err(ApiError::EmptyTargets);\n    }\n\n    let client = if let Some(leech_uuid) = leech_uuid {\n        GLOBAL.leeches.get_leech(&amp;leech_uuid)?\n    } else {\n        GLOBAL.leeches.random_leech()?\n    };\n\n    let (attack_uuid, _) = start_port_guesser(\n        workspace_uuid,\n        user_uuid,\n        client,\n        PortGuesserParams { targets, num_ports },\n    )\n    .await?;\n\n    Ok(HttpResponse::Accepted().json(UuidResponse { uuid: attack_uuid }))\n}\n</code></pre>"},{"location":"contribution/new_attack/#frontends-code","title":"Frontend's code","text":""},{"location":"contribution/new_attack/#9-expose-api-functions-and-structs","title":"9. Expose API functions and structs","text":"<p>In <code>kraken/src/api/server.rs</code> register your endpoints:</p> <p>Example</p> <pre><code>    ...\n    .service(attacks::handler::service_detection)\n    .service(attacks::handler::udp_service_detection)\n    .service(attacks::handler::dns_resolution)\n    .service(attacks::handler::dns_txt_scan)\n    .service(attacks::handler::port_guesser)\n    ...\n    .service(attack_results::handler::get_service_detection_results)\n    .service(attack_results::handler::get_udp_service_detection_results)\n    .service(attack_results::handler::get_dns_resolution_results)\n    .service(attack_results::handler::get_dns_txt_scan_results)\n    .service(attack_results::handler::get_port_guesser_results)\n</code></pre> <p>In <code>kraken/src/api/swagger.rs</code> register all your endpoints and custom data structures:</p> <p>Example</p> <pre><code>    ...\n    attacks::handler::dns_resolution,\n    attacks::handler::dns_txt_scan,\n    attacks::handler::port_guesser,\n    ...\n    attack_results::handler::get_dns_resolution_results,\n    attack_results::handler::get_dns_txt_scan_results,\n    attack_results::handler::get_port_guesser_results,\n    ...\n    attacks::schema::DnsResolutionRequest,\n    attacks::schema::DnsTxtScanRequest,\n    attacks::schema::PortGuesserRequest,\n    ...\n    attack_results::schema::SimpleDnsTxtScanResult,\n    attack_results::schema::FullDnsTxtScanResult,\n    attack_results::schema::PortGuesserResult,\n\n    ...\n    // as well as new types you expose inside the Request/Result types:\n    models::DnsTxtScanSpfType,\n    models::DnsTxtScanServiceHintType,\n    models::DnsTxtScanSummaryType,\n</code></pre>"},{"location":"contribution/new_attack/#10-make-it-build-again","title":"10. Make it build again","text":"<ul> <li> <p>Run <code>yarn gen-api</code></p> <p>Don't forget to download the newest <code>openapi.json</code> first!</p> </li> <li> <p>Add an entry in the <code>ATTACKS</code> object in <code>kraken_frontend/src/utils/attack-resolver.ts</code></p> </li> </ul> <p>Example</p> <pre><code>export const ATTACKS: AttackResolver = {\n    // ...\n    PortGuesser: { abbreviation: \"PG\", long: \"Port guesser\", key: \"portGuesser\" },\n}\n</code></pre> <ul> <li>Wrap the API endpoint in <code>kraken_frontend/src/api/api.ts</code></li> </ul> <p>Example</p> <pre><code>import {\n    ...\n    PortGuesserRequest,\n    ...\n} from \"./generated\";\n...\nportGuesser: (attack: PortGuesserRequest) =&gt; handleError(attacks.portGuesser({ portGuesserRequest: attack })),\n</code></pre>"},{"location":"contribution/new_attack/#11-make-it-usable","title":"11. Make it usable","text":"<p>TODO</p>"},{"location":"contribution/rust/","title":"Rust style guidelines","text":""},{"location":"contribution/rust/#run-clippy-before-submitting-a-pr-for-reviewing","title":"Run clippy before submitting a PR for reviewing","text":"<p>Clippy is a nice tool to check common pitfalls and anti-patterns. Its lints get often turned into lints of the compiler.</p> <pre><code>cargo clippy --no-deps --workspace --exclude kraken-sdk \n</code></pre>"},{"location":"contribution/rust/#formatting-with-rustfmt","title":"Formatting with <code>rustfmt</code>","text":"<p><code>rustfmt</code> is used to format the complete rust codebase and only on weird formatting cases, the <code>#[rustfmt::skip]</code> annotation should be used.</p> <p>Run <code>rustfmt</code> with the following parameters:</p> <pre><code>rustfmt --config imports_granularity=\"Item,group_imports=StdExternalCrate\" $FILE\n</code></pre> <p>You can also run <code>rustfmt</code> on the whole project:</p> <pre><code>cargo +nightly fmt\n</code></pre>"},{"location":"contribution/rust/#use-and-mod-prevalence","title":"Use and mod prevalence","text":"<p>Module declarations should always be declared after the use statements.</p> <p>Do: <pre><code>use std::fs::create_dir;\n\nuse uuid::Uuid;\n\nmod bar;\nmod foo;\n</code></pre></p> <p>Don't: <pre><code>mod bar;\nmod foo;\n\nuse std::fs::create_dir;\n\nuse uuid::Uuid;\n</code></pre></p>"},{"location":"contribution/rust/#module-local-imports-reexports","title":"Module-local imports / reexports","text":"<p>Use statements should either use the <code>crate</code>, <code>super</code> or <code>self</code> as top-level path-segments instead of implicit relative paths.</p> <p>This is important as <code>rustfmt</code> would move the corresponding use statements in the \"external crate\" section.</p> <p>Do: <pre><code>use self::bar::*;\n\nmod bar;\n</code></pre></p> <p>Don't: <pre><code>use bar::*;\n\nmod bar;\n</code></pre></p>"},{"location":"contribution/rust/#avoid-into","title":"Avoid <code>.into()</code>","text":"<p>Use <code>Y::from(x)</code> instead of <code>x.into()</code></p> <p>Calling <code>.into()</code> on a value is tempting, especially when used in a chain of several calls. However, it can be quite difficult to follow what is converted into what.</p> <p>Do: <pre><code>let bar = Bar::from(foo);\nlet baz = Baz::try_from(bar)?;\n</code></pre></p> <p>Don't <pre><code>let bar = foo.into();\nlet baz = bar.try_into();\n</code></pre></p>"},{"location":"contribution/typescript/","title":"Typescript","text":""},{"location":"contribution/typescript/#linter","title":"Linter","text":"<p>Eslint (invoked as <code>yarn lint</code>) is used as external linter to catch common pitfalls and anti-patterns.</p> <p>It is also configured to enforce some of our style choices.</p> <p>Please run <code>yarn lint</code> before opening a PR or configure you're IDE to run <code>eslint</code> (with our config!) on the fly.</p> <p>The config is located in <code>eslint.config.js</code> using <code>eslint</code>'s new config format.</p>"},{"location":"contribution/typescript/#formatter","title":"Formatter","text":"<p>Prettier (invoked as <code>yarn format</code>) is used as formatter.</p> <p>Please run <code>yarn format</code> before opening a PR or configure you're IDE to run <code>prettier</code> (with our config!) on the fly.</p> <p>The config is located directly in the <code>package.json</code>.</p>"},{"location":"contribution/typescript/#dos-and-donts","title":"Do's and Don'ts","text":""},{"location":"contribution/typescript/#components","title":"Components","text":"<p>Only use Functional components in React for new components.</p> <p>Rationale: state manipulation and caching can be written much simpler as well as it being what the react developers recommend.</p>"},{"location":"contribution/typescript/#conditional-class-names","title":"Conditional class names","text":"<p>When adding class names to a react element based on conditions use template literals in combination with the <code>?</code> operator</p> <p>Do</p> <p><pre><code>{/* The following will produce a &lt;div /&gt; with the class \"always\".                        */}\n{/* If the `condition1` is `true` the div will also have the class \"conditional-class1\". */}\n{/* Likewise for `condition2` and \"conditional-class2\"                                   */}\n&lt;div\n    className={`always ${\n        condition1 ? \"conditional-class1\" : \"\"\n    } ${\n        condition2 ? \"conditional-class2\" : \"\"\n    }`}\n/&gt;\n</code></pre> (The concrete indentation should be handled by our auto-formatter <code>prettier</code>.)</p> <p>Don't</p> <p><pre><code>&lt;div\n    className={\"always\" + condition1 ? \" conditional-class1\" : \"\" + condition2 ? \" conditional-class2\" : \"\"}\n/&gt;\n</code></pre> <pre><code>&lt;div\n    className={condition1 ? \"always conditional-class1\" : \"always\"}\n/&gt;\n</code></pre> <pre><code>&lt;div\n    className={[\n        \"always\",\n        ...(condition1 ? \"conditional-class1\" : []),\n        ...(condition1 ? \"conditional-class1\" : [])\n    ].join(\" \")}\n/&gt;\n</code></pre></p>"},{"location":"contribution/typescript/#rational","title":"Rational","text":"<ol> <li>Flexible: Can be scaled to any number of conditions</li> <li>First-class javascript features: This approach uses basic language features without any library api to learn</li> <li>JetBrains IDE support: The IDE understands that the template string will produce class names     and allows quick-navigation to the css class declarations.</li> </ol>"},{"location":"user/filter/","title":"Kraken's filters","text":"<p>Kraken uses a small custom language to filter certain views, most notably the \"Data\" view in a workspace.</p>"},{"location":"user/filter/#grammar","title":"Grammar","text":"<p>A filter consists of any number of rules where is rule is assigns a value to a key:</p> <p>Example</p> <p><code>domain: docs.kraken-project.org</code></p> <p>You can also assign a list of values combined using the basic logic operations:</p> <p>Example</p> <p><code>domains: docs.kraken-project.org, kraken-project.org</code> (<code>,</code> is a logical <code>OR</code>)</p> <p><code>tags: ignore &amp; !ok</code> (<code>&amp;</code> is a logical <code>AND</code> and <code>!</code> is a logical <code>NOT</code>)</p> <p>Note</p> <p>Most keys accept both singular and plural forms and there is no semantic difference between them</p> <p>Some values can (or have to) be expressed in ranges, for example ports.</p> <p>We use <code>-</code> to construct ranges.</p> <p>The lower and upper bounds are both inclusive and optional.</p> <p>Example</p> <p>The following are all semantically equivalent:</p> <p><code>port: 1-1000</code> <code>port: -1000</code> <code>port: !1001-</code></p>"},{"location":"user/filter/#operator-precedence","title":"Operator precedence","text":"<p>The filter syntax doesn't support parentheses or similar concepts to modify the order in which logic operations are executed.</p> <p><code>!</code> is always applied first, <code>&amp;</code> second and <code>,</code> last.</p> <p>(The range operator <code>-</code> is considered as part of the value and therefore applied before the <code>!</code>.)</p>"},{"location":"user/filter/#string-escaping","title":"String escaping","text":"<p>Strings are not required to be wrapped in <code>\"</code>.</p> <p>However, if they are not, the mustn't contain any operator including the <code>:</code> used to separate the key from its value.</p>"},{"location":"user/filter/#ebnf-excluding-whitespace","title":"EBNF (excluding whitespace)","text":"<pre><code>Filter = { Rule };\nRule = Key, \":\", Or;\nOr = And, { \",\", And};\nAnd = Not, { \"&amp;\", Not };\nNot = [ \"!\" ], ( Value | Range );\nRange = [ Value ], \"-\", [ Value ];\nKey = RawString;\nValue = EscapedString | RawString;\nEscapedString = '\"', { ? any character except \" ? }, '\"';\nRawString = { ? any character except the used special characters ? };\n</code></pre>"},{"location":"user/filter/#targets-and-their-keys","title":"Targets and their keys","text":"<p>There are 5 different targets a filter might be applied to:</p> <ul> <li><code>Global</code> which can be applied everywhere any of the other targets can be applied</li> <li><code>Domain</code></li> <li><code>Host</code></li> <li><code>Port</code></li> <li><code>Service</code></li> <li><code>HTTP Service</code></li> </ul>"},{"location":"user/filter/#keys","title":"Keys","text":"<p>Each target has its own set of allowed keys:</p> Target Key Type Example all targets tag[s] string <code>tag: critical</code> createdAt time range <code>createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> Domain domain[s] string <code>domain: docs.kraken-project.org</code> ip[s] ip address or network <code>ip: 127.0.0.1</code>, <code>ip: 127.0.0.1/24</code> sourceOf string <code>sourceOf: docs.kraken-project.org</code> targetOf string <code>targetOf: docs.kraken-project.org</code> Host ip[s] ip address or network <code>ip: 127.0.0.1</code>, <code>ip: 127.0.0.1/24</code> os os type <code>os: linux</code>, <code>os: windows</code> port[s] port number or range <code>port: 80</code>, <code>port: 1-1000</code> service[s] string <code>service: http</code> domain[s] string <code>domain: docs.kraken-project.org</code> Port port[s] port number or range <code>port: 80</code>, <code>port: 1-1000</code> ip[s] ip address or network <code>ip: 127.0.0.1</code>, <code>ip: 127.0.0.1/24</code> protocol[s] port protocol <code>protocol: tcp</code> service[s] string <code>service: http</code> Service service[s] string <code>service: http</code> ip[s] ip address or network <code>ip: 127.0.0.1</code>, <code>ip: 127.0.0.1/24</code> port[s] port number or range <code>port: 80</code>, <code>port: 1-1000</code> protocol[s] port protocol <code>protocol: tcp</code> transport[s] service transport <code>transport: tls</code>, <code>transport: raw</code> HTTP Service httpService[s] string <code>httpService: wordpress</code> ip[s] ip address or network <code>ip: 127.0.0.1</code>, <code>ip: 127.0.0.1/24</code> port[s] port number or range <code>port: 80</code>, <code>port: 1-1000</code> domain[s] string <code>domain: docs.kraken-project.org</code> basePath[s] string <code>basePath: /wp-admin/</code> tls boolean <code>tls: yes</code> sni boolean <code>sni: yes</code>"},{"location":"user/filter/#subkeys","title":"Subkeys","text":"<p>The keys <code>domain</code>, <code>sourceOf</code>, <code>targetOf</code>, <code>ip</code>, <code>port</code>, <code>service</code> and <code>httpService</code> each represent a target.</p> <p>You can use subkeys to query a different property of those targets instead of their main ones.</p> <p>For example <code>port.protocol: tcp</code> on a <code>Host</code> would filter for TCP ports instead of a specific port number.</p> Target Key Subkey Type Example Domain ip[s] tag[s] string <code>ip.tag: critical</code> createdAt time range <code>ip.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> os os type <code>ip.os: linux</code>, <code>ip.os: windows</code> sourceOf tag[s] string <code>sourceOf.tag: critical</code> createdAt time range <code>sourceOf.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> targetOf tag[s] string <code>targetOf.tag: critical</code> createdAt time range <code>targetOf.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> Host port[s] protocol[s] port protocol <code>port.protocol: tcp</code> tag[s] port protocol <code>port.tag: critical</code> createdAt time range <code>port.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> service[s] port[s] port number or range <code>service.port: 80</code>, <code>service.port: 1-1000</code> protocol[s] port protocol <code>serivce.protocol: tcp</code> tag[s] port protocol <code>service.tag: critical</code> createdAt time range <code>service.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> transport[s] service transport <code>service.transport: raw</code>, <code>service.transport: tls</code> domain[s] tag[s] string <code>domain.tag: critical</code> createdAt time range <code>domain.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> Port ip[s] tag[s] string <code>ip.tag: critical</code> createdAt time range <code>ip.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> os os type <code>ip.os:linux</code>, <code>ip.os:windows</code> service[s] tag[s] string <code>service.tag: critical</code> createdAt time range <code>service.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> transport[s] service transport <code>service.transport: raw</code>, <code>service.transport: tls</code> Service ip[s] tag[s] string <code>ip.tag: critical</code> createdAt time range <code>ip.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> os os type <code>ip.os:linux</code>, <code>ip.os:windows</code> port[s] tag[s] string <code>port.tag: critical</code> createdAt time range <code>port.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> HTTP Service ip[s] tag[s] string <code>ip.tag: critical</code> createdAt time range <code>ip.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> os os type <code>ip.os:linux</code>, <code>ip.os:windows</code> port[s] tag[s] string <code>port.tag: critical</code> createdAt time range <code>port.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code> domain[s] tag[s] string <code>domain.tag: critical</code> createdAt time range <code>domain.createdAt: \"2012-12-12T12:00:00Z\"-\"2012-12-13T12:00:00Z\"</code>"},{"location":"user/filter/#type-values","title":"Type values","text":"Type Valid values ip address or network IPv4 or IPv6 in CIDR notation os type <code>unknown</code>, <code>linux</code>, <code>windows</code>, <code>apple</code>, <code>android</code>, <code>freebsd</code> port number decimal port number (1-65535) - Usually valid as a range like <code>1000-2000</code> port protocol <code>tcp</code>, <code>udp</code>, <code>sctp</code>, <code>unknown</code> service transport <code>raw</code>, <code>tls</code> boolean <code>true</code> or <code>yes</code>, <code>false</code> or <code>no</code> string any valid string like described above, quoted if it contains whitespace, <code>,</code>, <code>&amp;</code>, <code>!</code>, <code>:</code>, <code>\"</code> or <code>-</code> time RFC3339 / ISO 8601 datetime: <code>\"yyyy-mm-ddThh:mm:ssZ\"</code> - Usually valid as a range The <code>T</code> may be replaced with a space. The timezone must be UTC (<code>Z</code>) or a fixed offset (<code>+0200</code> / <code>-01:30</code>)"}]}