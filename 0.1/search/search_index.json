{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contribution/dev_setup/","title":"Development Environment","text":""},{"location":"contribution/dev_setup/#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>The easiest way to get kraken running locally is using Vagrant and the provided Vagrantfile, which starts and uses virtual machines that take care of most things automatically, including compilation, through Ansible.</p>"},{"location":"contribution/dev_setup/#vagrantvarsyml","title":"<code>vagrant/vars.yml</code>","text":"<p>Copy the <code>example.vars.yml</code> to <code>vars.yml</code> in the vagrant folder and set test values for the tokens, names and passwords. A sample <code>vars.yml</code> might start like this:</p> <pre><code>---\n- kraken_db_name: \"kraken\"\n  kraken_db_user: \"kraken\"\n  kraken_db_password: \"\"\n  kraken_secret_key: \"\"\n  origin_uri: \"https://kraken.localhost\"\n  server_name: \"kraken.localhost\"\n  leech_db_name: \"leech\"\n  leech_db_user: \"leech\"\n  leech_db_password: \"\"\n  ...\n</code></pre> <p>The server will only listen to requests on the <code>origin_uri</code> URL. For this example, you can add <code>127.0.0.1   kraken.localhost</code> to your <code>/etc/hosts</code> file.</p> <p>The <code>kraken_secret_key</code> and <code>generated_leech_conf</code> blocks can first be left as-is and need to be filled with generated information after the first startup.</p>"},{"location":"contribution/dev_setup/#creating-vms","title":"Creating VMs","text":"<p>Before the first startup, if you don't have a high-spec machine with 8 or more cores, make sure to reduce the VM CPUs inside the root Vagrantfile in the checked out kraken repository. Using more VM CPUs than what are available on the host may cause hangups and slowdowns. If you change these values later, you can restart the VM with the config using <code>vagrant reload</code></p> <p>Now, initialize the VMs and perform a first compilation using</p> <pre><code>$ vagrant up\n</code></pre> <p>If you access http://kraken.localhost:8081 now, you should see a broken black page saying \"Loading...\" as well as showing errors.</p>"},{"location":"contribution/dev_setup/#setup-admin-user-and-kraken-key","title":"Setup admin user and kraken key","text":"<p>Now open a shell in the VM using</p> <pre><code>$ vagrant ssh\n</code></pre> <p>and inside this shell create an admin user by running <pre><code>$ sudo kraken create-admin-user\nEnter a username:\nEnter a display name:\nEnter password:\n[2023-12-13 11:12:17 | DEBUG | rorm_db::database] SQL: SELECT \"user\".\"uuid\" AS user__uuid FROM \"user\" WHERE (\"user\".username = $1) LIMIT 1;\n[2023-12-13 11:12:17 | DEBUG | rorm_db::database] SQL: INSERT INTO \"user\" (\"uuid\", \"username\", \"display_name\", \"permission\") VALUES ($1, $2, $3, 'Admin');\n[2023-12-13 11:12:17 | DEBUG | rorm_db::database] SQL: INSERT INTO \"localuser\" (\"uuid\", \"user\", \"password_hash\") VALUES ($1, $2, $3);\n\nCreated user admin\n</code></pre></p> <p>Following this run keygen:</p> <pre><code>$ sudo kraken keygen\nuRi7GQJkXSSM9oeYvOunX5X0izMSLOq5CItHC...\n</code></pre> <p>Copy the key that is output from this command and put it into <code>kraken_secret_key</code> inside your <code>vars.yml</code> file.</p> <p>Now exit the shell with Ctrl+D and since we edited <code>vars.yml</code> you need to re-provision the VM:</p> <pre><code>$ vagrant provision kraken\n</code></pre> <p>Now reload the Kraken webpage (http://kraken.localhost:8081) and login using the credentials that you have entered previously.</p>"},{"location":"contribution/dev_setup/#first-time-configuration","title":"First-time configuration","text":"<p>Once logged in as admin, go to the \"Kraken Network\" page and click \"Add leech\"</p> <p>Pick any name, for example \"Default leech\" and as address use</p> <pre><code>https://10.13.37.11:31337\n</code></pre> <p>When added to the list, click on \"Gen tls config\"</p> <p>The TLS config will be copied to clipboard (KrakenSni, KrakenCa, etc.). Paste this configuration inside your <code>vars.yml</code> as value for the <code>generated_leech_conf</code> field. (note that you need to indent the string to avoid YAML syntax errors)</p> <p>Now since <code>vars.yml</code> has been modified, you need to re-provision the leech VM again:</p> <pre><code>$ vagrant provision leech\n</code></pre> <p>The leech should be available now and attacks in workspaces can now be done.</p>"},{"location":"contribution/dev_setup/#internal-files","title":"Internal files","text":"<p>The following paths are used for storage and configuration: <pre><code>kraken:\n    /etc/kraken/config.toml\n    /var/lib/kraken\n\nleech:\n    /etc/leech/config.toml\n</code></pre></p>"},{"location":"contribution/new_attack/","title":"How to implement a new attack","text":""},{"location":"contribution/new_attack/#leechs-code","title":"Leech's code","text":""},{"location":"contribution/new_attack/#1-the-actual-logic","title":"1. The actual logic","text":"<ul> <li>Create a new rust module under <code>leech/src/modules</code></li> <li>It should expose a single async function to run your attack</li> <li>Figure out if your attack should be streamed or not</li> </ul> <p>Example</p> <pre><code>pub struct PortGuesserSettings {\n    pub addresses: Vec&lt;IpNetwork&gt;,\n    pub num_ports: u32,\n}\npub struct PortGuesserResult {\n    pub host: IpAddr,\n    pub port: u16,\n}\npub type PortGuesserError = SendError&lt;PortGuesserResult&gt;;\n\npub async fn port_guesser(\n    settings: PortGuesserSettings,\n    tx: Sender&lt;PortGuesserResult&gt;, // &lt;- this attack is streamed so we \"return\" our results through a channel\n) -&gt; Result&lt;(), PortGuesserError&gt; {\n    let mut rng = StdRng::from_entropy();\n    for network in settings.addresses {\n        for addr in network.iter() {\n            for _ in 0..settings.num_ports {\n                tx.send(PortGuesserResult {\n                    host: addr,\n                    port: rng.gen_range(1..=u16::MAX),\n                })\n                .await?;\n            }\n        }\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"contribution/new_attack/#2-expose-it-on-the-cli","title":"2. Expose it on the cli","text":"<ul> <li>Create a new <code>RunCommand</code> variant in <code>leech/src/main.rs</code></li> <li> <p>Add the associated match arm to execute your function in <code>fn main()</code></p> <p>(the compiler will tell you where)</p> </li> </ul> <p>Example</p> <pre><code>#[derive(Subcommand)]\npub enum RunCommand {\n    // ...\n\n    PortGuesser {\n        #[clap(required(true))]\n        targets: Vec&lt;String&gt;,\n\n        #[clap(short, long, default_value_t = 4)]\n        num_ports: u32,\n    },\n}\n\n// inside main\nmatch command {\n    // ...\n\n    RunCommand::PortGuesser { targets, num_ports } =&gt; {\n        let addresses = targets\n            .iter()\n            .map(|s| IpNetwork::from_str(s))\n            .collect::&lt;Result&lt;_, _&gt;&gt;()?;\n        let (tx, mut rx) = mpsc::channel(1);\n        task::spawn(port_guesser(\n            PortGuesserSettings {\n                addresses,\n                num_ports,\n            },\n            tx,\n        ));\n        while let Some(res) = rx.recv().await {\n            info!(\"I guess {}:{} is open\", res.host, res.port);\n        }\n    }\n}\n</code></pre>"},{"location":"contribution/new_attack/#3-expose-it-over-grpc","title":"3. Expose it over grpc","text":"<ul> <li>Create two new message types in <code>proto/attacks.proto</code>, a <code>...Request</code> and a <code>...Response</code></li> <li>The request should contain your function's arguments and the response should contain its results</li> <li>Extend <code>ReqAttackService</code> with a new call using your request and response messages</li> <li> <p>Extend the <code>PushAttackRequest.response</code> with your new response</p> <p>(make it repeated if your attack is streamed)</p> </li> <li> <p>Extend the <code>AnyAttackResponse.response</code> with your new response</p> <p>(never make it repeated)</p> </li> <li> <p>Implement the new method on <code>ReqAttackService</code>, the compiler will now complain about</p> <p>It should convert the <code>...Request</code> object to your functions arguments and its result to <code>...Response</code>.</p> <p>When your attack is streamed, you might find the function <code>stream_attack</code> helpful to construct the return value.</p> </li> </ul> <p>Example</p> <pre><code>message PortGuesserRequest {\n  string attack_uuid = 1;\n  repeated attacks.shared.NetOrAddress targets = 2;\n  uint32 num_ports = 3;\n}\n\nmessage PortGuesserResponse {\n  attacks.shared.Address host = 1;\n  uint32 port = 2;\n}\n\nservice ReqAttackService {\n  // ...\n\n  rpc PortGuesser(PortGuesserRequest) returns (stream PortGuesserResponse);\n}\n</code></pre> <pre><code>message PushAttackRequest {\n  // ...\n\n  oneof response {\n    // ...\n\n    RepeatedPortGuesserResponse port_guesser = 9;\n    // ^\n    // | if the attack is not streamed, just use `PortGuesserResponse` here\n  }\n}\n\nmessage RepeatedPortGuesserResponse {\n  repeated PortGuesserResponse responses = 1;\n}\n</code></pre> <pre><code>message AnyAttackResponse {\n  // ...\n\n  oneof response {\n    // ...\n\n    PortGuesserResponse port_guesser = 8;\n  }\n}\n</code></pre> <pre><code>impl ReqAttackService for Attacks {\n    // ...\n\n    type PortGuesserStream =\n        Pin&lt;Box&lt;dyn Stream&lt;Item = Result&lt;PortGuesserResponse, Status&gt;&gt; + Send&gt;&gt;;\n\n    async fn port_guesser(\n        &amp;self,\n        request: Request&lt;PortGuesserRequest&gt;,\n    ) -&gt; Result&lt;Response&lt;Self::PortGuesserStream&gt;, Status&gt; {\n        let req = request.into_inner();\n\n        let attack_uuid = Uuid::parse_str(&amp;req.attack_uuid)\n            .map_err(|_| Status::invalid_argument(\"attack_uuid has to be an Uuid\"))?;\n\n        let settings = PortGuesserSettings {\n            addresses: req.targets.into_iter().map(|el| el.into()).collect(),\n            num_ports: req.num_ports,\n        };\n\n        self.stream_attack(\n            attack_uuid,\n            |tx| async move {\n                port_guesser(settings, tx)\n                    .await\n                    .map_err(|_| Status::unknown(\"\"))\n            },\n            |value| PortGuesserResponse {\n                host: Some(value.host.into()),\n                port: value.port as u32,\n            },\n            any_attack_response::Response::PortGuesser,\n        )\n    }\n}\n</code></pre> <p>Info</p> <p>kraken won't compile anymore</p>"},{"location":"contribution/new_attack/#krakens-code","title":"Kraken's code","text":""},{"location":"contribution/new_attack/#4-db-models","title":"4. DB models","text":"<ul> <li>Add your new attack type to <code>AttackType</code> in <code>kraken/src/models/attack/mod.rs</code>   and <code>SourceType</code> in <code>kraken/src/models/aggregation/mod.rs</code></li> <li> <p>Add models in <code>kraken/src/models/attack/mod.rs</code> to store your attack's raw results</p> <p>(A raw result is the <code>...Response</code> message you defined in step 3)</p> <p>Don't forget to create an insertable patch as well!</p> </li> </ul> <p>Warning</p> <p>Please consult your project lead on how to migrate the <code>AttackType</code> and <code>SourceType</code> enums</p> <p>Example</p> <p><pre><code>#[derive(DbEnum)]\npub enum SourceType {\n    // ...\n\n    PortGuesser,\n}\n\n#[derive(DbEnum)]\npub enum AttackType {\n    // ...\n\n    PortGuesser,\n}\n</code></pre> <pre><code>#[derive(Model)]\npub struct PortGuesserResult {\n    #[rorm(primary_key)]\n    pub uuid: Uuid,\n\n    #[rorm(on_delete = \"Cascade\", on_update = \"Cascade\")]\n    pub attack: ForeignModel&lt;Attack&gt;,\n\n    #[rorm(auto_create_time)]\n    pub created_at: DateTime&lt;Utc&gt;,\n\n    pub host: IpNetwork,\n\n    pub port: i32,\n}\n\n#[derive(Patch)]\n#[rorm(model = \"PortGuesserResult\")]\npub(crate) struct PortGuesserResultInsert {\n    pub(crate) uuid: Uuid,\n    pub(crate) attack: ForeignModel&lt;Attack&gt;,\n    pub(crate) host: IpNetwork,\n    pub(crate) port: i32,\n}\n</code></pre></p>"},{"location":"contribution/new_attack/#5-handle-your-grpc-messages","title":"5. Handle your grpc messages","text":"<ul> <li> <p>Implement <code>HandleAttackResponse&lt;...Response&gt;</code> for <code>AttackContext</code></p> <p>This is done in an attack specific submodule in <code>kraken/src/modules/attacks</code>.</p> <p>The <code>handle_response</code> method, you will have to implement, should:</p> <ul> <li>Validate and convert your <code>...Response</code> message</li> <li> <p>Notify the user via <code>self.send_ws</code></p> <p>(you might need to create a new websocket message type)</p> </li> <li> <p>Store the raw result</p> </li> <li>Update the aggregations via <code>GLOBAL.aggregator</code></li> <li>Connect the raw result with the aggregated models using the <code>AggregationSource</code> m2m relation</li> </ul> </li> <li> <p>Extend the 3 match statements in <code>kraken/src/rpc/server.rs</code> using your <code>AttackType</code> variant and <code>handle_response</code> impl.</p> </li> </ul> <p>Example</p> <p><pre><code>impl HandleAttackResponse&lt;PortGuesserResponse&gt; for AttackContext {\n    async fn handle_response(&amp;self, response: PortGuesserResponse) -&gt; Result&lt;(), AttackError&gt; {\n        let PortGuesserResponse {\n            host: Some(host),\n            port,\n        } = response\n        else {\n            return Err(AttackError::Malformed(\"Missing `host`\"));\n        };\n        let host = IpNetwork::from(IpAddr::try_from(host)?);\n\n        let source_uuid = insert!(&amp;GLOBAL.db, PortGuesserResultInsert)\n            .return_primary_key()\n            .single(&amp;PortGuesserResultInsert {\n                uuid: Uuid::new_v4(),\n                attack: ForeignModelByField::Key(self.attack_uuid),\n                host,\n                port: port as i32,\n            })\n            .await?;\n\n        let host_uuid = GLOBAL\n            .aggregator\n            .aggregate_host(self.workspace.uuid, host, HostCertainty::SupposedTo)\n            .await?;\n        let port_uuid = GLOBAL\n            .aggregator\n            .aggregate_port(\n                self.workspace.uuid,\n                host_uuid,\n                port as u16,\n                PortProtocol::Tcp,\n                PortCertainty::SupposedTo,\n            )\n            .await?;\n\n        insert!(&amp;GLOBAL.db, AggregationSource)\n            .return_nothing()\n            .bulk([\n                AggregationSource {\n                    uuid: Uuid::new_v4(),\n                    workspace: ForeignModelByField::Key(self.workspace.uuid),\n                    source_type: SourceType::PortGuesser,\n                    source_uuid,\n                    aggregated_table: AggregationTable::Host,\n                    aggregated_uuid: host_uuid,\n                },\n                AggregationSource {\n                    uuid: Uuid::new_v4(),\n                    workspace: ForeignModelByField::Key(self.workspace.uuid),\n                    source_type: SourceType::PortGuesser,\n                    source_uuid,\n                    aggregated_table: AggregationTable::Port,\n                    aggregated_uuid: port_uuid,\n                },\n            ])\n            .await?;\n\n        Ok(())\n    }\n}\n</code></pre> <pre><code>// three match expressions in kraken/src/rpc/server.rs\n\nmatch &amp;response {\n    // ...\n    push_attack_request::Response::PortGuesser(_) =&gt; AttackType::PortGuesser,\n},\n\nlet result = match response {\n    // ...\n    push_attack_request::Response::PortGuesser(repeated) =&gt; {\n        attack.handle_vec_response(repeated.responses).await\n    }\n};\n\nlet result: Result&lt;(), _&gt; = match response {\n    // ...\n    any_attack_response::Response::PortGuesser(response) =&gt; {\n        attack_context.handle_response(response).await\n    }\n};\n</code></pre></p>"},{"location":"contribution/new_attack/#6-write-schemas-and-handler-to-retrieve-raw-results","title":"6. Write schemas and handler to retrieve raw results","text":"<p>Write an http handler in <code>kraken/src/api/handler/attack_results/handler.rs</code> to query your raw attack results (the model you created in step 4).</p> <p>We are doing this step now, because you'll have to write new schemas for the handler's response, which we'll also need in the next step.</p> <p>Example</p> <p><pre><code>#[derive(Serialize, Deserialize, ToSchema, Debug, Clone)]\npub struct SimplePortGuesserResult {\n    pub uuid: Uuid,\n    pub attack: Uuid,\n    pub created_at: DateTime&lt;Utc&gt;,\n    #[schema(value_type = String, example = \"127.0.0.1\")]\n    pub address: IpNetwork,\n    pub port: u16,\n}\n</code></pre> <pre><code>#[utoipa::path(\n    tag = \"Attacks\",\n    context_path = \"/api/v1\",\n    responses(\n        (status = 200, description = \"Returns attack's results\", body = PortGuesserResultsPage),\n        (status = 400, description = \"Client error\", body = ApiErrorResponse),\n        (status = 500, description = \"Server error\", body = ApiErrorResponse),\n    ),\n    params(PathUuid, PageParams),\n    security((\"api_key\" = []))\n)]\n#[get(\"/attacks/{uuid}/portGuesserResults\")]\npub async fn get_port_guesser_results(\n    path: Path&lt;PathUuid&gt;,\n    page_params: Query&lt;PageParams&gt;,\n    SessionUser(user_uuid): SessionUser,\n) -&gt; ApiResult&lt;Json&lt;PortGuesserResultsPage&gt;&gt; {\n    let mut tx = GLOBAL.db.start_transaction().await?;\n\n    let attack_uuid = path.uuid;\n    let (limit, offset) = get_page_params(page_params.0).await?;\n\n    if !Attack::has_access(&amp;mut tx, attack_uuid, user_uuid).await? {\n        return Err(ApiError::MissingPrivileges);\n    }\n\n    let (total,) = query!(&amp;mut tx, (PortGuesserResult::F.uuid.count(),))\n        .condition(PortGuesserResult::F.attack.equals(attack_uuid))\n        .one()\n        .await?;\n\n    let items = query!(&amp;mut tx, PortGuesserResult)\n        .condition(PortGuesserResult::F.attack.equals(attack_uuid))\n        .limit(limit)\n        .offset(offset)\n        .stream()\n        .map_ok(|x| SimplePortGuesserResult {\n            uuid: x.uuid,\n            attack: *x.attack.key(),\n            created_at: x.created_at,\n            address: x.host,\n            port: x.port as u16,\n        })\n        .try_collect()\n        .await?;\n\n    tx.commit().await?;\n\n    Ok(Json(Page {\n        items,\n        limit,\n        offset,\n        total: total as u64,\n    }))\n}\n</code></pre></p>"},{"location":"contribution/new_attack/#7-handle-the-new-sourcetype","title":"7. Handle the new <code>SourceType</code>","text":"<ul> <li>Add a new <code>usize</code> field to <code>SimpleAggregationSource</code> in <code>kraken/src/api/handler/aggregation_source/schema.rs</code></li> <li>Increment this field in <code>SimpleAggregationSource::add</code> in <code>kraken/src/api/handler/aggregation_source/utils.rs</code></li> <li>Add a new variant to <code>SourceAttackResult</code> in <code>kraken/src/api/handler/aggregation_source/schema.rs</code></li> <li>Add the logic required to query your attack type's raw results for a specific aggregated model   (<code>FullAggregationSource::query</code> in <code>kraken/src/api/handler/aggregation_source/utils.rs</code>)</li> </ul> <p>Example</p> <p><pre><code>pub struct SimpleAggregationSource {\n    // ...\n\n    pub port_guesser: usize,\n}\n</code></pre> <pre><code>match source_type {\n    // ...\n\n    SourceType::PortGuesser =&gt; self.port_guesser += 1,\n}\n</code></pre> <pre><code>pub enum SourceAttackResult {\n  // ...\n\n  PortGuesser(Vec&lt;SimplePortGuesserResult&gt;),\n}\n</code></pre> <pre><code>type Results&lt;T&gt; = HashMap&lt;Uuid, Vec&lt;T&gt;&gt;;\n// ...\nlet mut port_guesser: Results&lt;SimplePortGuesserResult&gt; = Results::new();\n\n// ...\n\nmatch source_type {\n    // ...\n\n    SourceType::PortGuesser =&gt; {\n        let mut stream = query!(&amp;mut *tx, PortGuesserResult)\n            .condition(field_in(PortGuesserResult::F.uuid, uuids))\n            .stream();\n        while let Some(result) = stream.try_next().await? {\n            port_guesser.entry(*result.attack.key()).or_default().push(\n                SimplePortGuesserResult {\n                    uuid: result.uuid,\n                    attack: *result.attack.key(),\n                    created_at: result.created_at,\n                    address: result.host,\n                    port: result.port as u16,\n                },\n            );\n        }\n    }\n}\n\n// ...\n\nmatch attack_type {\n    // ...\n\n    AttackType::PortGuesser =&gt; SourceAttackResult::PortGuesser(\n        port_guesser.remove(&amp;uuid).unwrap_or_default(),\n    ),\n}\n</code></pre></p> <p>Info</p> <p>kraken should compile again</p> <p>frontend's data view will break</p>"},{"location":"contribution/new_attack/#8-expose-it-over-the-api","title":"8. Expose it over the API","text":"<ul> <li> <p>Add a method to <code>AttackContext</code> in your submodule of <code>kraken/src/modules/attacks</code> which runs the attack</p> <p>This method should be a thin wrapper which converts the attack's params to grpc and handle the response.</p> <p>(Use <code>handle_response</code> you implemented in step 5 or <code>handle_streamed_response</code> if you're attack is streamed)</p> </li> <li> <p>Add a function in <code>kraken/src/modules/attacks/mod.rs</code> which calls this method in a new task</p> </li> <li> <p>Add an endpoint in <code>kraken/src/api/handler/attacks/handler.rs</code> which calls this function</p> </li> </ul> <p>Warning</p> <p>Don't forget to register all the schemas and endpoints you created in <code>kraken/src/api/swagger.rs</code></p> <p>Example</p> <pre><code>impl AttackContext {\n    pub async fn port_guesser(\n        &amp;self,\n        mut leech: LeechClient,\n        params: PortGuesserParams,\n    ) -&gt; Result&lt;(), AttackError&gt; {\n        let targets =\n            DomainOrNetwork::resolve(self.workspace.uuid, self.user.uuid, &amp;leech, &amp;params.targets)\n                .await?;\n\n        self.handle_streamed_response(leech.port_guesser(PortGuesserRequest {\n            attack_uuid: self.attack_uuid.to_string(),\n            targets: targets.into_iter().map(From::from).collect(),\n            num_ports: params.num_ports,\n        }))\n        .await\n    }\n}\n</code></pre> <pre><code>pub struct PortGuesserParams {\n    pub targets: Vec&lt;DomainOrNetwork&gt;,\n    pub num_ports: u32,\n}\npub async fn start_port_guesser(\n    workspace: Uuid,\n    user: Uuid,\n    leech: LeechClient,\n    params: PortGuesserParams,\n) -&gt; Result&lt;(Uuid, JoinHandle&lt;()&gt;), InsertAttackError&gt; {\n    let ctx = AttackContext::new(workspace, user, AttackType::PortGuesser).await?;\n    Ok((\n        ctx.attack_uuid,\n        tokio::spawn(async move {\n            ctx.set_started().await;\n            let result = ctx.port_guesser(leech, params).await;\n            ctx.set_finished(result).await;\n        }),\n    ))\n}\n</code></pre> <pre><code>#[derive(Deserialize, Serialize, Debug, ToSchema)]\npub struct PortGuesserRequest {\n  pub leech_uuid: Option&lt;Uuid&gt;,\n  #[schema(value_type = Vec&lt;String&gt;)]\n  pub targets: Vec&lt;DomainOrNetwork&gt;,\n  pub num_ports: u32,\n  pub workspace_uuid: Uuid,\n}\n</code></pre> <pre><code>#[utoipa::path(\n    tag = \"Attacks\",\n    context_path = \"/api/v1\",\n    responses(\n        (status = 202, description = \"Attack scheduled\", body = UuidResponse),\n        (status = 400, description = \"Client error\", body = ApiErrorResponse),\n        (status = 500, description = \"Server error\", body = ApiErrorResponse)\n    ),\n    request_body = PortGuesserRequest,\n    security((\"api_key\" = []))\n)]\n#[post(\"/attacks/portGuesser\")]\npub async fn port_guesser(\n    req: Json&lt;PortGuesserRequest&gt;,\n    SessionUser(user_uuid): SessionUser,\n) -&gt; ApiResult&lt;HttpResponse&gt; {\n    let PortGuesserRequest {\n        leech_uuid,\n        targets,\n        num_ports,\n        workspace_uuid,\n    } = req.into_inner();\n\n    if targets.is_empty() {\n        return Err(ApiError::EmptyTargets);\n    }\n\n    let client = if let Some(leech_uuid) = leech_uuid {\n        GLOBAL.leeches.get_leech(&amp;leech_uuid)?\n    } else {\n        GLOBAL.leeches.random_leech()?\n    };\n\n    let (attack_uuid, _) = start_port_guesser(\n        workspace_uuid,\n        user_uuid,\n        client,\n        PortGuesserParams { targets, num_ports },\n    )\n    .await?;\n\n    Ok(HttpResponse::Accepted().json(UuidResponse { uuid: attack_uuid }))\n}\n</code></pre>"},{"location":"contribution/new_attack/#frontends-code","title":"Frontend's code","text":""},{"location":"contribution/new_attack/#9-make-it-build-again","title":"9. Make it build again","text":"<ul> <li> <p>Run <code>yarn gen-api</code></p> <p>Don't forget to download the newest <code>openapi.json</code> first!</p> </li> <li> <p>Add an entry in the <code>ATTACKS</code> object in <code>kraken_frontend/src/utils/attack-resolver.ts</code></p> </li> </ul> <p>Example</p> <pre><code>export const ATTACKS: AttackResolver = {\n    // ...\n    PortGuesser: { abbreviation: \"PG\", long: \"Port guesser\", key: \"portGuesser\" },\n}\n</code></pre>"},{"location":"contribution/new_attack/#10-make-it-usable","title":"10. Make it usable","text":"<p>TODO</p>"},{"location":"contribution/rust/","title":"Rust style guidelines","text":""},{"location":"contribution/rust/#run-clippy-before-submitting-a-pr-for-reviewing","title":"Run clippy before submitting a PR for reviewing","text":"<p>Clippy is a nice tool to check common pitfalls and anti-patterns. Its lints get often turned into lints of the compiler.</p> <pre><code>cargo clippy --no-deps --workspace --exclude kraken-sdk \n</code></pre>"},{"location":"contribution/rust/#formatting-with-rustfmt","title":"Formatting with <code>rustfmt</code>","text":"<p><code>rustfmt</code> is used to format the complete rust codebase and only on weird formatting cases, the <code>#[rustfmt::skip]</code> annotation should be used.</p> <p>Run <code>rustfmt</code> with the following parameters:</p> <pre><code>rustfmt --config imports_granularity=\"Module,group_imports=StdExternalCrate\" $FILE\n</code></pre>"},{"location":"contribution/rust/#use-and-mod-prevalence","title":"Use and mod prevalence","text":"<p>Module declarations should always be declared after the use statements.</p> <p>Do: <pre><code>use std::fs::create_dir;\n\nuse uuid::Uuid;\n\nmod bar;\nmod foo;\n</code></pre></p> <p>Don't: <pre><code>mod bar;\nmod foo;\n\nuse std::fs::create_dir;\n\nuse uuid::Uuid;\n</code></pre></p>"},{"location":"contribution/rust/#module-local-imports-reexports","title":"Module-local imports / reexports","text":"<p>Use statements should either use the <code>crate</code>, <code>super</code> or <code>self</code> as top-level path-segments instead of implicit relative paths.</p> <p>This is important as <code>rustfmt</code> would move the corresponding use statements in the \"external crate\" section.</p> <p>Do: <pre><code>use self::bar::*;\n\nmod bar;\n</code></pre></p> <p>Don't: <pre><code>use bar::*;\n\nmod bar;\n</code></pre></p>"},{"location":"contribution/rust/#avoid-into","title":"Avoid <code>.into()</code>","text":"<p>Use <code>Y::from(x)</code> instead of <code>x.into()</code></p> <p>Calling <code>.into()</code> on a value is tempting, especially when used in a chain of several calls. However, it can be quite difficult to follow what is converted into what.</p> <p>Do: <pre><code>let bar = Bar::from(foo);\nlet baz = Baz::try_from(bar)?;\n</code></pre></p> <p>Don't <pre><code>let bar = foo.into();\nlet baz = bar.try_into();\n</code></pre></p>"},{"location":"contribution/typescript/","title":"Typescript","text":""},{"location":"contribution/typescript/#conditional-class-names","title":"Conditional class names","text":"<p>When adding class names to a react element based on conditions use template literals in combination with the <code>?</code> operator</p>"},{"location":"contribution/typescript/#do","title":"Do:","text":"<p><pre><code>{/* The following will produce a &lt;div /&gt; with the class \"always\".                        */}\n{/* If the `condition1` is `true` the div will also have the class \"conditional-class1\". */}\n{/* Likewise for `condition2` and \"conditional-class2\"                                   */}\n&lt;div\n    className={`always ${\n        condition1 ? \"conditional-class1\" : \"\"\n    } ${\n        condition2 ? \"conditional-class2\" : \"\"\n    }`}\n/&gt;\n</code></pre> (The concrete indentation should be handled by our auto-formatter <code>prettier</code>.)</p>"},{"location":"contribution/typescript/#dont-do","title":"Don't Do:","text":"<p><pre><code>&lt;div\n    className={\"always\" + condition1 ? \" conditional-class1\" : \"\" + condition2 ? \" conditional-class2\" : \"\"}\n/&gt;\n</code></pre> <pre><code>&lt;div\n    className={condition1 ? \"always conditional-class1\" : \"always\"}\n/&gt;\n</code></pre> <pre><code>&lt;div\n    className={[\n        \"always\",\n        ...(condition1 ? \"conditional-class1\" : []),\n        ...(condition1 ? \"conditional-class1\" : [])\n    ].join(\" \")}\n/&gt;\n</code></pre></p>"},{"location":"contribution/typescript/#rational","title":"Rational","text":"<ol> <li>Flexible: Can be scaled to any number of conditions</li> <li>First-class javascript features: This approach uses basic language features without any library api to learn</li> <li>JetBrains IDE support: The IDE understands that the template string will produce class names     and allows quick-navigation to the css class declarations.</li> </ol>"}]}