{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contribution/rust/","title":"Run clippy before submitting a PR for reviewing","text":"<p>Clippy is a nice tool to check common pitfalls and anti-patterns. Its lints get often turned into lints of the compiler.</p> <pre><code>cargo clippy --no-deps --workspace --exclude kraken-sdk \n</code></pre>"},{"location":"contribution/rust/#formatting-with-rustfmt","title":"Formatting with <code>rustfmt</code>","text":"<p><code>rustfmt</code> is used to format the complete rust codebase and only on weird formatting cases, the <code>#[rustfmt::skip]</code> annotation should be used.</p> <p>Run <code>rustfmt</code> with the following parameters:</p> <pre><code>rustfmt --config imports_granularity=\"Module,group_imports=StdExternalCrate\" $FILE\n</code></pre>"},{"location":"contribution/rust/#use-and-mod-prevalence","title":"Use and mod prevalence","text":"<p>Module declarations should always be declared after the use statements.</p> <p>Do: <pre><code>use std::fs::create_dir;\n\nuse uuid::Uuid;\n\nmod bar;\nmod foo;\n</code></pre></p> <p>Don't: <pre><code>mod bar;\nmod foo;\n\nuse std::fs::create_dir;\n\nuse uuid::Uuid;\n</code></pre></p>"},{"location":"contribution/rust/#module-local-imports-reexports","title":"Module-local imports / reexports","text":"<p>Use statements should either use the <code>crate</code>, <code>super</code> or <code>self</code> as top-level path-segments instead of implicit relative paths.</p> <p>This is important as <code>rustfmt</code> would move the corresponding use statements in the \"external crate\" section.</p> <p>Do: <pre><code>use self::bar::*;\n\nmod bar;\n</code></pre></p> <p>Don't: <pre><code>use bar::*;\n\nmod bar;\n</code></pre></p>"},{"location":"contribution/typescript/","title":"Typescript","text":""},{"location":"contribution/typescript/#conditional-class-names","title":"Conditional class names","text":"<p>When adding class names to a react element based on conditions use template literals in combination with the <code>?</code> operator</p>"},{"location":"contribution/typescript/#do","title":"Do:","text":"<p><pre><code>{/* The following will produce a &lt;div /&gt; with the class \"always\".                        */}\n{/* If the `condition1` is `true` the div will also have the class \"conditional-class1\". */}\n{/* Likewise for `condition2` and \"conditional-class2\"                                   */}\n&lt;div\n    className={`always ${\n        condition1 ? \"conditional-class1\" : \"\"\n    } ${\n        condition2 ? \"conditional-class2\" : \"\"\n    }`}\n/&gt;\n</code></pre> (The concrete indentation should be handled by our auto-formatter <code>prettier</code>.)</p>"},{"location":"contribution/typescript/#dont-do","title":"Don't Do:","text":"<p><pre><code>&lt;div\n    className={\"always\" + condition1 ? \" conditional-class1\" : \"\" + condition2 ? \" conditional-class2\" : \"\"}\n/&gt;\n</code></pre> <pre><code>&lt;div\n    className={condition1 ? \"always conditional-class1\" : \"always\"}\n/&gt;\n</code></pre> <pre><code>&lt;div\n    className={[\n        \"always\",\n        ...(condition1 ? \"conditional-class1\" : []),\n        ...(condition1 ? \"conditional-class1\" : [])\n    ].join(\" \")}\n/&gt;\n</code></pre></p>"},{"location":"contribution/typescript/#rational","title":"Rational","text":"<ol> <li>Flexible: Can be scaled to any number of conditions</li> <li>First-class javascript features: This approach uses basic language features without any library api to learn</li> <li>JetBrains IDE support: The IDE understands that the template string will produce class names     and allows quick-navigation to the css class declarations.</li> </ol>"}]}